using Commissiestrijd.Data;
using Commissiestrijd.Models;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Swashbuckle.AspNetCore.Annotations;

namespace Commissiestrijd.Controllers;

/// <summary>
/// Controller for handling leaderboard operations.
/// This controller allows users to retrieve the leaderboard based on submitted tasks within a specified date range.
/// It checks if the user is authorized before allowing access to the leaderboard.
/// The leaderboard is generated by summing the points of approved tasks grouped by committee.
/// </summary>
[ApiController]
[Route("[controller]")]
public class LeaderboardController : Controller
{
    /// <summary>
    /// The database context used to interact with the application's data.
    /// </summary>
    private readonly AppDbContext _context;

    /// <summary>
    /// The logger used for logging information and errors in the controller.
    /// This logger is used to log various events and errors that occur during the execution of the controller's actions,
    /// helping with debugging and monitoring the application's behavior.
    /// </summary>
    private readonly ILogger<LeaderboardController> _logger;

    /// <summary>
    /// Constructor for the LeaderboardController.
    /// Initializes the controller with the provided database context and logger.
    /// This constructor is used to set up the necessary dependencies for the controller,
    /// allowing it to access submitted task data and log information or errors during operations.
    /// </summary>
    /// <param name="context">
    /// The database context used to access the application's data.
    /// </param>
    /// <param name="logger">
    /// The logger used for logging information or errors during operations.
    /// </param>
    public LeaderboardController(AppDbContext context, ILogger<LeaderboardController> logger)
    {
        _context = context;
        _logger = logger;
    }

    /// <summary>
    /// Retrieves the leaderboard based on submitted tasks within a specified date range.
    /// This method allows users to get the leaderboard by providing a start date and an end date
    /// for the period they want to analyze.
    /// The leaderboard is generated by summing the points of approved tasks grouped by committee,
    /// and ordered by points in descending order.
    /// The method validates the date range to ensure the start date is not after the end date
    /// and that the dates are treated as UTC dates.
    /// If the date range is valid, it retrieves all approved tasks within that range,
    /// filters out tasks that exceed the MaxPerPeriod limit,
    /// and then groups the tasks by committee to calculate the total points for each committee.
    /// </summary>
    /// <param name="StartDate">
    /// The start date of the period for which to retrieve the leaderboard.
    /// </param>
    /// <param name="EndDate">
    /// The end date of the period for which to retrieve the leaderboard.
    /// </param>
    /// <returns>
    /// An IActionResult containing the leaderboard data or a BadRequest result if the date range is
    /// invalid.
    /// </returns>
    /// <response code="200">
    /// Returns the leaderboard data as a list of anonymous objects containing committee names and their total points
    /// within the specified date range.
    /// </response>
    /// <response code="400">
    /// If the start date is after the end date, a BadRequest result is returned with an error message.
    /// </response>
    /// <response code="500">
    /// If an error occurs while processing the request, a 500 Internal Server Error result is
    /// returned.
    /// </response> 
    [Authorize]
    [HttpGet("GetLeaderboard")]
    [SwaggerOperation(Summary = "Get Leaderboard", Description = "This endpoint allows users to get the leaderboard by providing a start and end date for the period they want to analyze.")]
    [SwaggerResponse(200, "Returns the leaderboard data as a list of anonymous objects containing committee names and their total points within the specified date range.")]
    [ProducesResponseType(typeof(List<object>), 200)]
    [SwaggerResponse(400, "BadRequest if the start date is after the end date.")]
    [SwaggerResponse(500, "Internal Server Error if an error occurs while processing the request.")]
    public IActionResult GetLeaderboard([FromQuery] DateTime StartDate, [FromQuery] DateTime EndDate)
    {
        _logger.LogInformation("GetLeaderboard called with StartDate: {StartDate}, EndDate: {EndDate}", StartDate, EndDate);

        // Validate date range as UTC dates
        DateTime UtcStartTime = DateTime.SpecifyKind(StartDate, DateTimeKind.Utc).Date;
        DateTime UtcEndTime = DateTime.SpecifyKind(EndDate, DateTimeKind.Utc).Date;

        // Check if start date is not after end date
        if (UtcStartTime > UtcEndTime)
        {
            _logger.LogWarning("Start date {StartDate} is after end date {EndDate}.", UtcStartTime, UtcEndTime);
            return BadRequest("Start date cannot be after end date.");
        }

        // Get all approved tasks within the specified date range
        var allTasksInPeriod = _context.SubmittedTasks
            .Where(t => t.Status == SubmittedTask.TaskStatus.Approved &&
                        t.SubmittedAt.Date >= UtcStartTime &&
                        t.SubmittedAt.Date <= UtcEndTime)
            .OrderBy(t => t.SubmittedAt)
            .ToList();

        // Filter tasks that exceed the MaxPerPeriod limit
        var validTasks = new List<SubmittedTask>();
        foreach (var task in allTasksInPeriod)
        {
            // If MaxPerPeriod is null, it means no limit, so we can add the task
            if (task.MaxPerPeriod == null)
            {
                validTasks.Add(task);
            }
            else
            {
                // Else, count how many tasks with the same ID are already submitted before this one
                // If the count is less than MaxPerPeriod, we can add the task
                // Else, it exceeds the limit and we skip it
                int countBefore = validTasks
                    .Count(t => t.PossibleTaskId == task.PossibleTaskId && t.Committee == task.Committee);

                if (countBefore < task.MaxPerPeriod)
                {
                    validTasks.Add(task);
                }
            }
        }

        // Group by committee and sum points, then order by points descending
        var leaderboard = validTasks
            .GroupBy(t => t.Committee)
            .Select(g => new
            {
                Committee = g.Key,
                Points = g.Sum(t => t.Points)
            })
            .OrderByDescending(x => x.Points)
            .ToList();

        _logger.LogInformation("Leaderboard generated with {Count} committees.", leaderboard.Count);

        return Ok(leaderboard);
    }

    /// <summary>
    /// Get the leaderboard for a specific period by its name.
    /// This endpoint can be accessed without authentication.
    /// </summary>
    /// <param name="periodName">
    /// The name of the period to retrieve the leaderboard for.
    /// </param>
    /// <returns>
    /// The leaderboard data for the specified period.
    /// </returns>
    [HttpGet("GetLeaderboardByPeriodName")]
    [SwaggerOperation(Summary = "Get Leaderboard by Period Name", Description = "This endpoint allows users to get the leaderboard by providing a period name.")]
    [SwaggerResponse(200, "Returns the leaderboard data as a list of anonymous objects containing committee names and their total points for the specified period.")]
    [ProducesResponseType(typeof(List<object>), 200)]
    [SwaggerResponse(400, "BadRequest if the period name is invalid.")]
    [SwaggerResponse(404, "NotFound if no periods are found with the specified name.")]
    [SwaggerResponse(500, "Internal Server Error if an error occurs while processing the request.")]
    public IActionResult GetLeaderboardByPeriodName([FromQuery] string periodName)
    {
        _logger.LogInformation("GetLeaderboardByPeriodName called with periodName: {PeriodName}", periodName);

        // Validate the period name
        if (string.IsNullOrWhiteSpace(periodName))
        {
            _logger.LogWarning("Invalid period name provided.");
            return BadRequest("Invalid period name.");
        }

        // Get all periods containing the specified period name
        var periods = _context.Periods
            .Where(p => p.Name == periodName)
            .FirstOrDefault();

        if (periods == null)
        {
            _logger.LogWarning("No periods found with name: {PeriodName}", periodName);
            return NotFound("No periods found.");
        }

        // Get all approved tasks for the specified period
        var allTasksInPeriod = _context.SubmittedTasks
            .Where(t => t.Status == SubmittedTask.TaskStatus.Approved &&
                        t.SubmittedAt >= periods.StartDate &&
                        t.SubmittedAt <= periods.EndDate)
            .ToList();

        // Filter tasks that exceed the MaxPerPeriod limit
        var validTasks = new List<SubmittedTask>();
        foreach (var task in allTasksInPeriod)
        {
            // If MaxPerPeriod is null, it means no limit, so we can add the task
            if (task.MaxPerPeriod == null)
            {
                validTasks.Add(task);
            }
            else
            {
                // Else, count how many tasks with the same ID are already submitted before this one
                // If the count is less than MaxPerPeriod, we can add the task
                // Else, it exceeds the limit and we skip it
                int countBefore = validTasks
                    .Count(t => t.PossibleTaskId == task.PossibleTaskId && t.Committee == task.Committee);

                if (countBefore < task.MaxPerPeriod)
                {
                    validTasks.Add(task);
                }
            }
        }

        // Group by committee and sum points, then order by points descending
        var leaderboard = validTasks
            .GroupBy(t => t.Committee)
            .Select(g => new
            {
                Committee = g.Key,
                Points = g.Sum(t => t.Points)
            })
            .OrderByDescending(x => x.Points)
            .ToList();

        _logger.LogInformation("Leaderboard generated for period {PeriodName} with {Count} committees.", periodName, leaderboard.Count);

        return Ok(leaderboard);
    }

}
